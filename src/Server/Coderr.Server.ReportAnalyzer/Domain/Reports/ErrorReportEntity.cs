using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Local

namespace codeRR.Server.ReportAnalyzer.Domain.Reports
{
    /// <summary>
    ///     Represents the incoming error report, unmodified (to allow us to do further processing in the future)
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Important! The entity suffers from temporal coupling since we do not want to generate the hash code in the
    ///         receiving web API but in the core windows service. As such
    ///         the report can't be identified until the windows service has received it from the queue.
    ///     </para>
    /// </remarks>
    public class ErrorReportEntity
    {
        /// <summary>
        ///     Creates a new instance of <see cref="ErrorReportEntity" />.
        /// </summary>
        /// <param name="applicationId">Application that the report belongs to</param>
        /// <param name="clientReportId">error id generated by the client library</param>
        /// <param name="createdAtUtc">when the client library created the report</param>
        /// <param name="exception">exception</param>
        /// <param name="contexts">context collections</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentOutOfRangeException"></exception>
        public ErrorReportEntity(int applicationId, string clientReportId, DateTime createdAtUtc,
            ErrorReportException exception, IEnumerable<ErrorReportContext> contexts)
        {
            if (clientReportId == null) throw new ArgumentNullException("clientReportId");
            if (exception == null) throw new ArgumentNullException("exception");
            if (contexts == null) throw new ArgumentNullException("contexts");
            if (applicationId <= 0) throw new ArgumentOutOfRangeException("applicationId");

            ClientReportId = clientReportId;
            ApplicationId = applicationId;
            CreatedAtUtc = createdAtUtc;
            Exception = exception;
            //GenerateHashCodeIdentifier();
            ContextInfo = contexts.ToArray();
        }

        /// <summary>
        ///     Serialization constructor
        /// </summary>
        protected ErrorReportEntity()
        {
        }

        /// <summary>
        ///     PK of the application that this entity is reported for
        /// </summary>
        public int ApplicationId { get; set; }

        /// <summary>
        ///     Used to identify this incident when the hash code is the same as for other incidents.
        /// </summary>
        /// <summary>
        ///     Gets or sets id from the client library
        /// </summary>
        public string ClientReportId { get; private set; }

        /// <summary>
        ///     Context collection
        /// </summary>
        public ErrorReportContext[] ContextInfo { get; private set; }

        /// <summary>
        ///     When this entity was created (in the server)
        /// </summary>
        public DateTime CreatedAtUtc { get; private set; }

        /// <summary>
        ///     Thrown exception
        /// </summary>
        public ErrorReportException Exception { get; set; }

        /// <summary>
        ///     PK
        /// </summary>
        public int Id { get; private set; }

        /// <summary>
        ///     Gets incident that this report belongs to.
        /// </summary>
        public int IncidentId { get; set; }

        /// <summary>
        ///     Remote address from where the report was received.
        /// </summary>
        public string RemoteAddress { get; set; }


        /// <summary>
        ///     Hash code generated for the exception.
        /// </summary>
        /// <remarks>
        ///     Be aware that multiple different incidents (yes, <see cref="IncidentBeingAnalyzed" /> may have the same hash code).
        /// </remarks>
        public string ReportHashCode { get; private set; }

        /// <summary>
        ///     Denormalization to be able to generate lists quicker (this is really Exception.Message)
        /// </summary>
        public string Title { get; set; }


        /// <summary>
        ///     User/Site/application that the report is for.
        /// </summary>
        public ClaimsPrincipal User { get; set; }

        /// <summary>
        ///     Used when we get hash code collisions to identify the correct incident.
        /// </summary>
        public string GenerateHashCodeIdentifier()
        {
            var identifier = Exception.FullName + "\r\n";
            if (string.IsNullOrEmpty(Exception.StackTrace))
                return identifier;

            var trace = HashCodeGenerator.StripLineNumbers(Exception.StackTrace);
            var pos = trace.IndexOf("\r\n", StringComparison.Ordinal);
            if (pos != -1)
                identifier += trace.Substring(0, pos);

            return identifier;
        }

        /// <summary>
        ///     Temporal coupling, but the only way I could figure out.
        /// </summary>
        /// <param name="hashCode">hashcode used to see if this is an unique exception</param>
        /// <exception cref="ArgumentNullException">hashCode</exception>
        public void Init(string hashCode)
        {
            if (hashCode == null) throw new ArgumentNullException("hashCode");
            ReportHashCode = hashCode;
        }

        /// <summary>Returns a string that represents the current object.</summary>
        /// <returns>A string that represents the current object.</returns>
        /// <filterpriority>2</filterpriority>
        public override string ToString()
        {
            return Exception != null ? Exception.Message : "Exception was not included";
        }
    }
}